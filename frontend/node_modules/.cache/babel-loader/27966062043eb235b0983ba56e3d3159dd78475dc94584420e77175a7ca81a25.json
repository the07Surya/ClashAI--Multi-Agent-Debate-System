{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback, useRef } from 'react';\nconst useWebSocket = url => {\n  _s();\n  const [socket, setSocket] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [messages, setMessages] = useState([]);\n  const [error, setError] = useState(null);\n  const [connectionStatus, setConnectionStatus] = useState('disconnected');\n  const reconnectTimeoutRef = useRef(null);\n  const maxReconnectAttempts = 5;\n  const reconnectAttempts = useRef(0);\n  const mountedRef = useRef(true);\n  const connect = useCallback(() => {\n    if (!mountedRef.current) return;\n    try {\n      setConnectionStatus('connecting');\n      const ws = new WebSocket(url);\n      ws.onopen = () => {\n        if (!mountedRef.current) return;\n        console.log('✓ WebSocket connected');\n        setIsConnected(true);\n        setError(null);\n        setConnectionStatus('connected');\n        reconnectAttempts.current = 0;\n      };\n      ws.onmessage = event => {\n        if (!mountedRef.current) return;\n        try {\n          const message = JSON.parse(event.data);\n          setMessages(prev => [...prev, {\n            ...message,\n            id: Date.now() + Math.random()\n          }]);\n        } catch (err) {\n          console.error('Error parsing message:', err);\n        }\n      };\n      ws.onclose = event => {\n        if (!mountedRef.current) return;\n        console.log('WebSocket closed:', event.code);\n        setIsConnected(false);\n        setSocket(null);\n        setConnectionStatus('disconnected');\n\n        // Auto-reconnect with exponential backoff\n        if (reconnectAttempts.current < maxReconnectAttempts && event.code !== 1000) {\n          reconnectAttempts.current++;\n          const delay = Math.min(1000 * Math.pow(2, reconnectAttempts.current), 10000);\n          setConnectionStatus('reconnecting');\n          reconnectTimeoutRef.current = setTimeout(() => {\n            if (mountedRef.current) {\n              console.log(`Reconnecting... attempt ${reconnectAttempts.current}`);\n              connect();\n            }\n          }, delay);\n        } else {\n          setConnectionStatus('failed');\n        }\n      };\n      ws.onerror = error => {\n        console.error('WebSocket error:', error);\n        setError('Connection error');\n        setConnectionStatus('error');\n      };\n      setSocket(ws);\n    } catch (err) {\n      console.error('Failed to create WebSocket:', err);\n      setError('Failed to connect');\n      setConnectionStatus('failed');\n    }\n  }, [url]);\n  useEffect(() => {\n    connect();\n    return () => {\n      mountedRef.current = false;\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n      if (socket) {\n        socket.close(1000, 'Component unmounting');\n      }\n    };\n  }, [connect]);\n  const sendMessage = useCallback(message => {\n    if (socket && isConnected) {\n      try {\n        socket.send(JSON.stringify(message));\n        return true;\n      } catch (err) {\n        console.error('Failed to send message:', err);\n        setError('Failed to send message');\n        return false;\n      }\n    } else {\n      console.warn('WebSocket not connected');\n      return false;\n    }\n  }, [socket, isConnected]);\n  const clearMessages = useCallback(() => {\n    setMessages([]);\n  }, []);\n  return {\n    isConnected,\n    messages,\n    error,\n    connectionStatus,\n    sendMessage,\n    clearMessages\n  };\n};\n_s(useWebSocket, \"lcmy0crqyxBa+NkSGeiNbbZepro=\");\nexport default useWebSocket;","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","useWebSocket","url","_s","socket","setSocket","isConnected","setIsConnected","messages","setMessages","error","setError","connectionStatus","setConnectionStatus","reconnectTimeoutRef","maxReconnectAttempts","reconnectAttempts","mountedRef","connect","current","ws","WebSocket","onopen","console","log","onmessage","event","message","JSON","parse","data","prev","id","Date","now","Math","random","err","onclose","code","delay","min","pow","setTimeout","onerror","clearTimeout","close","sendMessage","send","stringify","warn","clearMessages"],"sources":["C:/Users/SuryaPratapRout/OneDrive - GyanSys Inc/Desktop/Apex/Chimera-Debate/Chimera-Clue/frontend/src/hooks/useWebSocket.jsx"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\r\n\r\nconst useWebSocket = (url) => {\r\n  const [socket, setSocket] = useState(null);\r\n  const [isConnected, setIsConnected] = useState(false);\r\n  const [messages, setMessages] = useState([]);\r\n  const [error, setError] = useState(null);\r\n  const [connectionStatus, setConnectionStatus] = useState('disconnected');\r\n  const reconnectTimeoutRef = useRef(null);\r\n  const maxReconnectAttempts = 5;\r\n  const reconnectAttempts = useRef(0);\r\n  const mountedRef = useRef(true);\r\n\r\n  const connect = useCallback(() => {\r\n    if (!mountedRef.current) return;\r\n    \r\n    try {\r\n      setConnectionStatus('connecting');\r\n      const ws = new WebSocket(url);\r\n      \r\n      ws.onopen = () => {\r\n        if (!mountedRef.current) return;\r\n        console.log('✓ WebSocket connected');\r\n        setIsConnected(true);\r\n        setError(null);\r\n        setConnectionStatus('connected');\r\n        reconnectAttempts.current = 0;\r\n      };\r\n\r\n      ws.onmessage = (event) => {\r\n        if (!mountedRef.current) return;\r\n        try {\r\n          const message = JSON.parse(event.data);\r\n          setMessages(prev => [...prev, { ...message, id: Date.now() + Math.random() }]);\r\n        } catch (err) {\r\n          console.error('Error parsing message:', err);\r\n        }\r\n      };\r\n\r\n      ws.onclose = (event) => {\r\n        if (!mountedRef.current) return;\r\n        console.log('WebSocket closed:', event.code);\r\n        setIsConnected(false);\r\n        setSocket(null);\r\n        setConnectionStatus('disconnected');\r\n        \r\n        // Auto-reconnect with exponential backoff\r\n        if (reconnectAttempts.current < maxReconnectAttempts && event.code !== 1000) {\r\n          reconnectAttempts.current++;\r\n          const delay = Math.min(1000 * Math.pow(2, reconnectAttempts.current), 10000);\r\n          setConnectionStatus('reconnecting');\r\n          \r\n          reconnectTimeoutRef.current = setTimeout(() => {\r\n            if (mountedRef.current) {\r\n              console.log(`Reconnecting... attempt ${reconnectAttempts.current}`);\r\n              connect();\r\n            }\r\n          }, delay);\r\n        } else {\r\n          setConnectionStatus('failed');\r\n        }\r\n      };\r\n\r\n      ws.onerror = (error) => {\r\n        console.error('WebSocket error:', error);\r\n        setError('Connection error');\r\n        setConnectionStatus('error');\r\n      };\r\n\r\n      setSocket(ws);\r\n    } catch (err) {\r\n      console.error('Failed to create WebSocket:', err);\r\n      setError('Failed to connect');\r\n      setConnectionStatus('failed');\r\n    }\r\n  }, [url]);\r\n\r\n  useEffect(() => {\r\n    connect();\r\n    \r\n    return () => {\r\n      mountedRef.current = false;\r\n      if (reconnectTimeoutRef.current) {\r\n        clearTimeout(reconnectTimeoutRef.current);\r\n      }\r\n      if (socket) {\r\n        socket.close(1000, 'Component unmounting');\r\n      }\r\n    };\r\n  }, [connect]);\r\n\r\n  const sendMessage = useCallback((message) => {\r\n    if (socket && isConnected) {\r\n      try {\r\n        socket.send(JSON.stringify(message));\r\n        return true;\r\n      } catch (err) {\r\n        console.error('Failed to send message:', err);\r\n        setError('Failed to send message');\r\n        return false;\r\n      }\r\n    } else {\r\n      console.warn('WebSocket not connected');\r\n      return false;\r\n    }\r\n  }, [socket, isConnected]);\r\n\r\n  const clearMessages = useCallback(() => {\r\n    setMessages([]);\r\n  }, []);\r\n\r\n  return {\r\n    isConnected,\r\n    messages,\r\n    error,\r\n    connectionStatus,\r\n    sendMessage,\r\n    clearMessages\r\n  };\r\n};\r\n\r\nexport default useWebSocket;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}